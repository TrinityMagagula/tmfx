<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <link rel="icon" href="images/logo 32.png" type="image/png">
  <title>TM FX Trading Terminal</title>
  <script type="module" src="auth.js"></script>
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    body {
      font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
      background-color: #0e0e0e;
      color: #ddd;
      overflow: hidden;
    }
    .navbar {
      background: #141414;
      padding: 10px 20px;
      display: flex;
      align-items: center;
      justify-content: space-between;
      border-bottom: 1px solid #2a2a2a;
      height: 40px;
    }
    .navbar h1 {
      color: #0fbcf9;
      font-size: 1.2rem;
    }
    .navbar-controls {
      display: flex;
      gap: 10px;
      align-items: center;
    }
    .navbar select, .navbar button {
      padding: 6px 12px;
      background: #1f1f1f;
      color: white;
      border: 1px solid #444;
      border-radius: 4px;
      cursor: pointer;
    }
    .navbar button:hover {
      background: #2a2a2a;
    }
    #chartContainer {
      width: 100%;
      height: calc(100vh - 40px);
      position: relative;
    }
    #chart {
      width: 100%;
      height: 100%;
      position: relative;
    }
    #drawing-layer {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      pointer-events: none;
      z-index: 10;
    }
    #toolbar {
      position: absolute;
      top: 10px;
      left: 10px;
      z-index: 20;
      display: flex;
      flex-direction: column;
      gap: 5px;
      background: rgba(30, 30, 30, 0.9);
      border-radius: 4px;
      padding: 5px;
      border: 1px solid #444;
    }
    .toolbar-group {
      display: flex;
      gap: 5px;
      padding: 5px;
      border-bottom: 1px solid #444;
    }
    .toolbar-group:last-child {
      border-bottom: none;
    }
    #toolbar button {
      background: #1f1f1f;
      color: #ddd;
      border: 1px solid #444;
      border-radius: 4px;
      width: 30px;
      height: 30px;
      display: flex;
      align-items: center;
      justify-content: center;
      cursor: pointer;
    }
    #toolbar button:hover {
      background: #2a2a2a;
    }
    #toolbar button.active {
      background: #0fbcf9;
      color: white;
    }
    #symbol-search {
      position: absolute;
      top: 10px;
      right: 10px;
      z-index: 20;
      background: rgba(30, 30, 30, 0.9);
      border-radius: 4px;
      padding: 5px;
      border: 1px solid #444;
      width: 200px;
      display: none;
    }
    #symbol-search.active {
      display: block;
    }
    #symbol-search input {
      width: 100%;
      padding: 5px;
      background: #1f1f1f;
      color: white;
      border: 1px solid #444;
      border-radius: 4px;
    }
    #symbol-list {
      max-height: 300px;
      overflow-y: auto;
      margin-top: 5px;
    }
    .symbol-item {
      padding: 5px;
      cursor: pointer;
    }
    .symbol-item:hover {
      background: #2a2a2a;
    }
    #timezone-display {
      position: absolute;
      bottom: 10px;
      right: 10px;
      z-index: 20;
      background: rgba(30, 30, 30, 0.7);
      color: #ddd;
      padding: 5px 10px;
      border-radius: 4px;
      font-size: 0.8rem;
      border: 1px solid #444;
    }
    #fullscreenBtn {
      position: absolute;
      bottom: 10px;
      left: 10px;
      z-index: 20;
      background-color: rgba(15, 188, 249, 0.1);
      border: 1px solid #0fbcf9;
      color: #0fbcf9;
      padding: 5px 10px;
      border-radius: 5px;
      font-size: 0.85rem;
      cursor: pointer;
      transition: background-color 0.3s;
    }
    #fullscreenBtn:hover {
      background-color: rgba(15, 188, 249, 0.2);
    }
    #chart-type-selector {
      position: absolute;
      top: 50px;
      left: 10px;
      z-index: 20;
      background: rgba(30, 30, 30, 0.9);
      border-radius: 4px;
      padding: 5px;
      border: 1px solid #444;
      display: none;
    }
    #chart-type-selector.active {
      display: block;
    }
    #chart-type-selector select {
      background: #1f1f1f;
      color: white;
      border: 1px solid #444;
      border-radius: 4px;
      padding: 5px;
    }
    #indicator-menu {
      position: absolute;
      top: 90px;
      left: 10px;
      z-index: 20;
      background: rgba(30, 30, 30, 0.9);
      border-radius: 4px;
      padding: 5px;
      border: 1px solid #444;
      width: 200px;
      display: none;
    }
    #indicator-menu.active {
      display: block;
    }
    .indicator-category {
      margin-bottom: 10px;
    }
    .indicator-category h4 {
      color: #0fbcf9;
      margin-bottom: 5px;
      cursor: pointer;
    }
    .indicator-items {
      padding-left: 15px;
    }
    .indicator-item {
      padding: 3px 0;
      cursor: pointer;
    }
    .indicator-item:hover {
      color: #0fbcf9;
    }
    #drawing-properties {
      position: absolute;
      bottom: 50px;
      left: 10px;
      z-index: 20;
      background: rgba(30, 30, 30, 0.9);
      border-radius: 4px;
      padding: 5px;
      border: 1px solid #444;
      display: none;
    }
    #drawing-properties.active {
      display: block;
    }
    .property-row {
      display: flex;
      align-items: center;
      margin-bottom: 5px;
    }
    .property-row label {
      min-width: 60px;
      font-size: 0.8rem;
    }
    .property-row input, .property-row select {
      width: 80px;
      background: #1f1f1f;
      color: white;
      border: 1px solid #444;
      border-radius: 4px;
      padding: 3px;
    }
    #chart-legend {
      position: absolute;
      top: 40px;
      right: 10px;
      z-index: 20;
      background: rgba(30, 30, 30, 0.9);
      border-radius: 4px;
      padding: 5px 10px;
      font-size: 0.8rem;
      border: 1px solid #444;
    }
    .legend-item {
      display: flex;
      align-items: center;
      margin: 3px 0;
    }
    .legend-color {
      width: 12px;
      height: 12px;
      margin-right: 5px;
      border-radius: 2px;
    }
    .drawing {
      position: absolute;
      pointer-events: none;
    }
    .drawing-line {
      position: absolute;
      transform-origin: 0 0;
      pointer-events: none;
    }
    .drawing-text {
      position: absolute;
      background: rgba(30, 30, 30, 0.7);
      padding: 2px 5px;
      border-radius: 3px;
      pointer-events: none;
      user-select: none;
    }
  </style>
</head>
<body id="everything">
  <div class="navbar">
    <h1>TM FX TradingView</h1>
    <div class="navbar-controls">
      <select id="timeframe">
        <option value="1m">1 Minute</option>
        <option value="5m">5 Minutes</option>
        <option value="15m">15 Minutes</option>
        <option value="30m">30 Minutes</option>
        <option value="1h">1 Hour</option>
        <option value="4h">4 Hours</option>
        <option value="1d">1 Day</option>
        <option value="1w">1 Week</option>
        <option value="1mn">1 Month</option>
      </select>
      <button id="theme-toggle"><i class="fas fa-moon"></i></button>
      <button id="symbol-search-toggle"><i class="fas fa-search"></i></button>
      <button id="chart-type-toggle"><i class="fas fa-chart-line"></i></button>
      <button id="indicator-toggle"><i class="fas fa-indent"></i></button>
    </div>
  </div>

  <div id="chartContainer">
    <div id="chart"></div>
    <div id="drawing-layer"></div>
    
    <!-- Toolbar for drawing tools -->
    <div id="toolbar">
      <div class="toolbar-group">
        <button id="select-tool" title="Select tool (V)"><i class="fas fa-mouse-pointer"></i></button>
        <button id="crosshair-tool" title="Crosshair (C)" class="active"><i class="fas fa-crosshairs"></i></button>
      </div>
      <div class="toolbar-group">
        <button id="line-tool" title="Line (L)"><i class="fas fa-slash"></i></button>
        <button id="ray-tool" title="Ray (R)"><i class="fas fa-long-arrow-alt-right"></i></button>
        <button id="horizontal-line-tool" title="Horizontal Line (H)"><i class="fas fa-arrows-alt-h"></i></button>
        <button id="vertical-line-tool" title="Vertical Line (V)"><i class="fas fa-arrows-alt-v"></i></button>
      </div>
      <div class="toolbar-group">
        <button id="trendline-tool" title="Trend Line (T)"><i class="fas fa-chart-line"></i></button>
        <button id="channel-tool" title="Channel (D)"><i class="fas fa-code-branch"></i></button>
        <button id="fibonacci-tool" title="Fibonacci Retracement (F)"><i class="fas fa-percentage"></i></button>
      </div>
      <div class="toolbar-group">
        <button id="rectangle-tool" title="Rectangle (S)"><i class="far fa-square"></i></button>
        <button id="circle-tool" title="Circle (O)"><i class="far fa-circle"></i></button>
        <button id="triangle-tool" title="Triangle (P)"><i class="fas fa-play"></i></button>
      </div>
      <div class="toolbar-group">
        <button id="text-tool" title="Text (A)"><i class="fas fa-font"></i></button>
        <button id="arrow-tool" title="Arrow (I)"><i class="fas fa-arrow-up"></i></button>
        <button id="measure-tool" title="Measure (U)"><i class="fas fa-ruler"></i></button>
      </div>
      <div class="toolbar-group">
        <button id="undo-tool" title="Undo (Ctrl+Z)"><i class="fas fa-undo"></i></button>
        <button id="redo-tool" title="Redo (Ctrl+Y)"><i class="fas fa-redo"></i></button>
        <button id="clear-tool" title="Clear drawings"><i class="fas fa-trash"></i></button>
      </div>
    </div>
    
    <!-- Symbol search -->
    <div id="symbol-search">
      <input type="text" placeholder="Search symbol..." id="symbol-search-input">
      <div id="symbol-list">
        <div class="symbol-item" data-symbol="SYNTHETIC">Synthetic Index</div>
        <div class="symbol-item" data-symbol="EURUSD">EUR/USD</div>
        <div class="symbol-item" data-symbol="GBPUSD">GBP/USD</div>
        <div class="symbol-item" data-symbol="USDJPY">USD/JPY</div>
        <div class="symbol-item" data-symbol="GOLD">Gold</div>
        <div class="symbol-item" data-symbol="SILVER">Silver</div>
        <div class="symbol-item" data-symbol="OIL">Crude Oil</div>
        <div class="symbol-item" data-symbol="BTCUSD">Bitcoin</div>
      </div>
    </div>
    
    <!-- Chart type selector -->
    <div id="chart-type-selector">
      <select id="chart-type">
        <option value="candlestick">Candlestick</option>
        <option value="bar">Bar</option>
        <option value="line">Line</option>
        <option value="area">Area</option>
        <option value="heikinashi">Heikin Ashi</option>
        <option value="baseline">Baseline</option>
      </select>
    </div>
    
    <!-- Indicator menu -->
    <div id="indicator-menu">
      <div class="indicator-category">
        <h4>Trend Indicators <i class="fas fa-chevron-down"></i></h4>
        <div class="indicator-items">
          <div class="indicator-item" data-indicator="movingaverage">Moving Average</div>
          <div class="indicator-item" data-indicator="ema">EMA</div>
          <div class="indicator-item" data-indicator="smoothedma">Smoothed MA</div>
          <div class="indicator-item" data-indicator="bollinger">Bollinger Bands</div>
          <div class="indicator-item" data-indicator="ichimoku">Ichimoku Cloud</div>
        </div>
      </div>
      <div class="indicator-category">
        <h4>Momentum Indicators <i class="fas fa-chevron-down"></i></h4>
        <div class="indicator-items">
          <div class="indicator-item" data-indicator="rsi">RSI</div>
          <div class="indicator-item" data-indicator="macd">MACD</div>
          <div class="indicator-item" data-indicator="stochastic">Stochastic</div>
          <div class="indicator-item" data-indicator="cci">CCI</div>
          <div class="indicator-item" data-indicator="momentum">Momentum</div>
        </div>
      </div>
      <div class="indicator-category">
        <h4>Volume Indicators <i class="fas fa-chevron-down"></i></h4>
        <div class="indicator-items">
          <div class="indicator-item" data-indicator="volume">Volume</div>
          <div class="indicator-item" data-indicator="vwap">VWAP</div>
          <div class="indicator-item" data-indicator="obv">OBV</div>
          <div class="indicator-item" data-indicator="accumdist">Accum/Dist</div>
        </div>
      </div>
    </div>
    
    <!-- Drawing properties panel -->
    <div id="drawing-properties">
      <div class="property-row">
        <label>Color:</label>
        <input type="color" id="drawing-color" value="#0fbcf9">
      </div>
      <div class="property-row">
        <label>Width:</label>
        <input type="number" id="drawing-width" min="1" max="10" value="2">
      </div>
      <div class="property-row">
        <label>Style:</label>
        <select id="drawing-style">
          <option value="0">Solid</option>
          <option value="1">Dotted</option>
          <option value="2">Dashed</option>
        </select>
      </div>
      <div class="property-row">
        <label>Opacity:</label>
        <input type="range" id="drawing-opacity" min="10" max="100" value="100">
      </div>
    </div>
    
    <!-- Chart legend -->
    <div id="chart-legend">
      <div class="legend-item">
        <div class="legend-color" style="background-color: #26a69a;"></div>
        <span>Synthetic Index</span>
      </div>
    </div>
    
    <!-- Timezone display -->
    <div id="timezone-display">
      <span id="timezone-text">GMT+0</span>
    </div>
    
    <!-- Fullscreen button -->
    <button id="fullscreenBtn">Fullscreen</button>
  </div>

  <script src="https://cdn.jsdelivr.net/npm/lightweight-charts@4.1.1/dist/lightweight-charts.standalone.production.js"></script>
  <script type="module">
    import { initializeApp } from "https://www.gstatic.com/firebasejs/10.11.0/firebase-app.js";
    import { getDatabase, ref, onChildAdded, onValue, off } from "https://www.gstatic.com/firebasejs/10.11.0/firebase-database.js";

    const firebaseConfig = {
      apiKey: "AIzaSyBIRVXFCPBpepPUEZz9aAbF-oVICVxTsec",
      authDomain: "mt-trading-signup-and-log-in.firebaseapp.com",
      databaseURL: "https://mt-trading-signup-and-log-in-default-rtdb.firebaseio.com",
      projectId: "mt-trading-signup-and-log-in",
      storageBucket: "mt-trading-signup-and-log-in.appspot.com",
      messagingSenderId: "101302422584",
      appId: "1:101302422584:web:07d472b05e81a6930beacd"
    };

    const app = initializeApp(firebaseConfig);
    const db = getDatabase(app);

    // Create chart with extended options
    const chart = LightweightCharts.createChart(document.getElementById("chart"), {
      layout: {
        background: { color: "#0e0e0e" },
        textColor: "#ccc",
        fontFamily: 'Segoe UI',
      },
      grid: {
        vertLines: { color: "#1f1f1f", style: 1 },
        horzLines: { color: "#1f1f1f", style: 1 },
      },
      timeScale: {
        timeVisible: true,
        secondsVisible: false,
        borderColor: "#2a2a2a",
        barSpacing: 6,
        minBarSpacing: 0.5,
        fixLeftEdge: true,
        fixRightEdge: true,
        tickMarkFormatter: (time, tickMarkType, locale) => {
          const date = new Date(time * 1000);
          switch (tickMarkType) {
            case 0: // Year
              return date.getFullYear();
            case 1: // Month
              return date.toLocaleString(locale, { month: 'short' });
            case 2: // Day of month
              return date.getDate();
            case 3: // Time
              return date.toLocaleTimeString(locale, { hour: '2-digit', minute: '2-digit' });
            case 4: // Time with seconds
              return date.toLocaleTimeString(locale, { hour: '2-digit', minute: '2-digit', second: '2-digit' });
            default:
              return '';
          }
        }
      },
      priceScale: {
        borderColor: "#2a2a2a",
        mode: 0, // 0 for normal, 1 for logarithmic, 2 for percentage, 3 for indexed to 100
        autoScale: true,
        invertScale: false,
        alignLabels: true,
        scaleMargins: {
          top: 0.1,
          bottom: 0.2,
        },
      },
      crosshair: {
        mode: LightweightCharts.CrosshairMode.Normal,
        vertLine: { 
          color: '#666', 
          width: 1,
          style: 1,
          labelBackgroundColor: '#1f1f1f',
        },
        horzLine: { 
          color: '#666', 
          width: 1,
          style: 1,
          labelBackgroundColor: '#1f1f1f',
        },
      },
      watermark: {
        color: 'rgba(150, 150, 150, 0.5)',
        visible: false,
        text: 'TM FX Trading',
        fontSize: 24,
        horzAlign: 'center',
        vertAlign: 'center',
      },
      localization: {
        timeFormatter: (time) => {
          const date = new Date(time * 1000);
          return date.toLocaleString();
        },
        priceFormatter: (price) => {
          return price.toFixed(2);
        },
      },
    });

    // Main candle series
    const candleSeries = chart.addCandlestickSeries({
      upColor: "#26a69a",
      downColor: "#ef5350",
      borderUpColor: "#26a69a",
      borderDownColor: "#ef5350",
      wickUpColor: "#26a69a",
      wickDownColor: "#ef5350",
      priceFormat: {
        type: 'price',
        precision: 2,
        minMove: 0.01,
      },
    });

    // Store all series for easy management
    const seriesMap = {
      'candlestick': candleSeries,
      'line': null,
      'bar': null,
      'area': null,
      'heikinashi': null,
      'baseline': null
    };

    // Store indicators
    const indicators = {};
    
    // Store drawings
    const drawings = [];
    let drawingHistory = [];
    let redoHistory = [];
    let activeDrawingTool = null;
    let currentDrawing = null;
    let isDrawing = false;
    
    // Drawing properties
    let drawingProperties = {
      color: '#0fbcf9',
      lineWidth: 2,
      lineStyle: 0,
      opacity: 100
    };

    // Timezone display
    const timezoneText = document.getElementById('timezone-text');
    const timezoneOffset = new Date().getTimezoneOffset();
    const timezone = `GMT${timezoneOffset <= 0 ? '+' : '-'}${Math.abs(timezoneOffset / 60)}`;
    timezoneText.textContent = timezone;

    // UI Toggles
    const symbolSearchToggle = document.getElementById('symbol-search-toggle');
    const chartTypeToggle = document.getElementById('chart-type-toggle');
    const indicatorToggle = document.getElementById('indicator-toggle');
    const symbolSearch = document.getElementById('symbol-search');
    const chartTypeSelector = document.getElementById('chart-type-selector');
    const indicatorMenu = document.getElementById('indicator-menu');

    symbolSearchToggle.addEventListener('click', () => {
      symbolSearch.classList.toggle('active');
      chartTypeSelector.classList.remove('active');
      indicatorMenu.classList.remove('active');
    });

    chartTypeToggle.addEventListener('click', () => {
      chartTypeSelector.classList.toggle('active');
      symbolSearch.classList.remove('active');
      indicatorMenu.classList.remove('active');
    });

    indicatorToggle.addEventListener('click', () => {
      indicatorMenu.classList.toggle('active');
      symbolSearch.classList.remove('active');
      chartTypeSelector.classList.remove('active');
    });

    // Close menus when clicking outside
    document.addEventListener('click', (e) => {
      if (!symbolSearch.contains(e.target) && e.target !== symbolSearchToggle) {
        symbolSearch.classList.remove('active');
      }
      if (!chartTypeSelector.contains(e.target) && e.target !== chartTypeToggle) {
        chartTypeSelector.classList.remove('active');
      }
      if (!indicatorMenu.contains(e.target) && e.target !== indicatorToggle) {
        indicatorMenu.classList.remove('active');
      }
    });

    // Load data
    let currentTimeframe = localStorage.getItem("tmfx-timeframe") || "1m";
    const timeframeSelect = document.getElementById("timeframe");
    timeframeSelect.value = currentTimeframe;

    let refCandles = null;
    let refLive = null;

    function loadCandles(timeframe) {
      candleSeries.setData([]);
      if (refCandles) off(refCandles);
      if (refLive) off(refLive);

      const refPath = `syntheticIndex/candles/${timeframe}`;
      const liveRefPath = `syntheticIndex/currentCandle/${timeframe}`;
      refCandles = ref(db, refPath);
      refLive = ref(db, liveRefPath);

      // Load full historical data
      onChildAdded(refCandles, (snap) => {
        const data = snap.val();
        if (data && data.time && data.open !== undefined) {
          candleSeries.update(data);
        }
      });

      // Live updating candle
      onValue(refLive, (snap) => {
        const data = snap.val();
        if (data && data.time && data.close !== undefined) {
          candleSeries.update(data);
        }
      });
    }

    timeframeSelect.addEventListener("change", (e) => {
      currentTimeframe = e.target.value;
      localStorage.setItem("tmfx-timeframe", currentTimeframe);
      loadCandles(currentTimeframe);
    });

    loadCandles(currentTimeframe);

    // Chart type switching
    chartTypeSelector.addEventListener('change', (e) => {
      const type = e.target.value;
      
      // Hide all series first
      Object.values(seriesMap).forEach(series => {
        if (series) {
          chart.removeSeries(series);
        }
      });
      
      // Create new series if needed
      if (!seriesMap[type]) {
        switch(type) {
          case 'line':
            seriesMap[type] = chart.addLineSeries({
              color: '#0fbcf9',
              lineWidth: 2,
              priceFormat: {
                type: 'price',
                precision: 2,
                minMove: 0.01,
              },
            });
            break;
          case 'bar':
            seriesMap[type] = chart.addBarSeries({
              upColor: '#26a69a',
              downColor: '#ef5350',
              priceFormat: {
                type: 'price',
                precision: 2,
                minMove: 0.01,
              },
            });
            break;
          case 'area':
            seriesMap[type] = chart.addAreaSeries({
              topColor: 'rgba(15, 188, 249, 0.4)',
              bottomColor: 'rgba(15, 188, 249, 0.1)',
              lineColor: '#0fbcf9',
              lineWidth: 2,
              priceFormat: {
                type: 'price',
                precision: 2,
                minMove: 0.01,
              },
            });
            break;
          case 'heikinashi':
            seriesMap[type] = chart.addCandlestickSeries({
              upColor: '#26a69a',
              downColor: '#ef5350',
              borderUpColor: '#26a69a',
              borderDownColor: '#ef5350',
              wickUpColor: '#26a69a',
              wickDownColor: '#ef5350',
              priceFormat: {
                type: 'price',
                precision: 2,
                minMove: 0.01,
              },
            });
            break;
          case 'baseline':
            seriesMap[type] = chart.addBaselineSeries({
              baseValue: { type: 'price', price: 0 },
              topLineColor: 'rgba( 38, 166, 154, 1)',
              topFillColor1: 'rgba( 38, 166, 154, 0.28)',
              topFillColor2: 'rgba( 38, 166, 154, 0.05)',
              bottomLineColor: 'rgba( 239, 83, 80, 1)',
              bottomFillColor1: 'rgba( 239, 83, 80, 0.05)',
              bottomFillColor2: 'rgba( 239, 83, 80, 0.28)',
              priceFormat: {
                type: 'price',
                precision: 2,
                minMove: 0.01,
              },
            });
            break;
        }
      }
      
      // Set data to the new series
      if (seriesMap[type]) {
        const currentData = candleSeries.data();
        if (currentData && currentData.length > 0) {
          seriesMap[type].setData(currentData);
        }
      }
    });

    // Theme toggle
    const themeToggle = document.getElementById('theme-toggle');
    themeToggle.addEventListener('click', () => {
      const isDark = document.body.style.backgroundColor === 'rgb(14, 14, 14)';
      
      if (isDark) {
        // Switch to light theme
        document.body.style.backgroundColor = '#ffffff';
        document.body.style.color = '#333';
        
        chart.applyOptions({
          layout: {
            background: { color: '#ffffff' },
            textColor: '#333',
          },
          grid: {
            vertLines: { color: '#e0e0e0' },
            horzLines: { color: '#e0e0e0' },
          },
          timeScale: {
            borderColor: '#e0e0e0',
          },
          priceScale: {
            borderColor: '#e0e0e0',
          },
          crosshair: {
            vertLine: { color: '#999' },
            horzLine: { color: '#999' },
          },
        });
        
        themeToggle.innerHTML = '<i class="fas fa-sun"></i>';
      } else {
        // Switch to dark theme
        document.body.style.backgroundColor = '#0e0e0e';
        document.body.style.color = '#ddd';
        
        chart.applyOptions({
          layout: {
            background: { color: '#0e0e0e' },
            textColor: '#ccc',
          },
          grid: {
            vertLines: { color: '#1f1f1f' },
            horzLines: { color: '#1f1f1f' },
          },
          timeScale: {
            borderColor: '#2a2a2a',
          },
          priceScale: {
            borderColor: '#2a2a2a',
          },
          crosshair: {
            vertLine: { color: '#666' },
            horzLine: { color: '#666' },
          },
        });
        
        themeToggle.innerHTML = '<i class="fas fa-moon"></i>';
      }
    });

    // Drawing tools implementation
    const selectTool = document.getElementById('select-tool');
    const crosshairTool = document.getElementById('crosshair-tool');
    const lineTool = document.getElementById('line-tool');
    const rayTool = document.getElementById('ray-tool');
    const horizontalLineTool = document.getElementById('horizontal-line-tool');
    const verticalLineTool = document.getElementById('vertical-line-tool');
    const trendlineTool = document.getElementById('trendline-tool');
    const channelTool = document.getElementById('channel-tool');
    const fibonacciTool = document.getElementById('fibonacci-tool');
    const rectangleTool = document.getElementById('rectangle-tool');
    const circleTool = document.getElementById('circle-tool');
    const triangleTool = document.getElementById('triangle-tool');
    const textTool = document.getElementById('text-tool');
    const arrowTool = document.getElementById('arrow-tool');
    const measureTool = document.getElementById('measure-tool');
    const undoTool = document.getElementById('undo-tool');
    const redoTool = document.getElementById('redo-tool');
    const clearTool = document.getElementById('clear-tool');
    const drawingPropertiesPanel = document.getElementById('drawing-properties');
    const drawingLayer = document.getElementById('drawing-layer');

    function activateTool(tool) {
      // Deactivate all tools first
      document.querySelectorAll('#toolbar button').forEach(btn => {
        btn.classList.remove('active');
      });
      
      // Activate selected tool
      tool.classList.add('active');
      activeDrawingTool = tool.id.replace('-tool', '');
      
      // Show/hide properties panel
      if (activeDrawingTool !== 'crosshair' && activeDrawingTool !== 'select') {
        drawingPropertiesPanel.classList.add('active');
      } else {
        drawingPropertiesPanel.classList.remove('active');
      }
      
      // Set crosshair mode
      if (activeDrawingTool === 'crosshair') {
        chart.applyOptions({
          crosshair: {
            mode: LightweightCharts.CrosshairMode.Normal,
          }
        });
      } else if (activeDrawingTool === 'select') {
        chart.applyOptions({
          crosshair: {
            mode: LightweightCharts.CrosshairMode.Normal,
          }
        });
      } else {
        chart.applyOptions({
          crosshair: {
            mode: LightweightCharts.CrosshairMode.Hidden,
          }
        });
      }
    }

    selectTool.addEventListener('click', () => activateTool(selectTool));
    crosshairTool.addEventListener('click', () => activateTool(crosshairTool));
    lineTool.addEventListener('click', () => activateTool(lineTool));
    rayTool.addEventListener('click', () => activateTool(rayTool));
    horizontalLineTool.addEventListener('click', () => activateTool(horizontalLineTool));
    verticalLineTool.addEventListener('click', () => activateTool(verticalLineTool));
    trendlineTool.addEventListener('click', () => activateTool(trendlineTool));
    channelTool.addEventListener('click', () => activateTool(channelTool));
    fibonacciTool.addEventListener('click', () => activateTool(fibonacciTool));
    rectangleTool.addEventListener('click', () => activateTool(rectangleTool));
    circleTool.addEventListener('click', () => activateTool(circleTool));
    triangleTool.addEventListener('click', () => activateTool(triangleTool));
    textTool.addEventListener('click', () => activateTool(textTool));
    arrowTool.addEventListener('click', () => activateTool(arrowTool));
    measureTool.addEventListener('click', () => activateTool(measureTool));

    // Initialize with crosshair tool active
    activateTool(crosshairTool);

    // Drawing properties controls
    const drawingColor = document.getElementById('drawing-color');
    const drawingWidth = document.getElementById('drawing-width');
    const drawingStyle = document.getElementById('drawing-style');
    const drawingOpacity = document.getElementById('drawing-opacity');

    drawingColor.addEventListener('input', (e) => {
      drawingProperties.color = e.target.value;
    });

    drawingWidth.addEventListener('input', (e) => {
      drawingProperties.lineWidth = parseInt(e.target.value);
    });

    drawingStyle.addEventListener('change', (e) => {
      drawingProperties.lineStyle = parseInt(e.target.value);
    });

    drawingOpacity.addEventListener('input', (e) => {
      drawingProperties.opacity = parseInt(e.target.value);
    });

    // Drawing implementation
    chart.subscribeClick((param) => {
      if (!param.point || !activeDrawingTool || activeDrawingTool === 'crosshair' || activeDrawingTool === 'select') {
        return;
      }

      if (!currentDrawing) {
        // Start new drawing
        currentDrawing = {
          tool: activeDrawingTool,
          points: [param.point],
          properties: {...drawingProperties},
          element: null
        };
        isDrawing = true;
      } else {
        // Add point to current drawing
        currentDrawing.points.push(param.point);
        
        // Complete drawing if it has enough points
        const pointsNeeded = {
          'line': 2,
          'ray': 2,
          'horizontal-line': 1,
          'vertical-line': 1,
          'trendline': 2,
          'channel': 3,
          'fibonacci': 2,
          'rectangle': 2,
          'circle': 2,
          'triangle': 3,
          'text': 1,
          'arrow': 2,
          'measure': 2
        };
        
        if (currentDrawing.points.length >= pointsNeeded[currentDrawing.tool]) {
          completeDrawing();
        }
      }
    });

    // Track mouse movement for drawing preview
    chart.subscribeCrosshairMove((param) => {
      if (!isDrawing || !currentDrawing || !param.point) return;
      
      // Update the last point with current mouse position
      if (currentDrawing.points.length > 0) {
        currentDrawing.points[currentDrawing.points.length - 1] = param.point;
        renderDrawingPreview(currentDrawing);
      }
    });

    function renderDrawingPreview(drawing) {
      // Clear previous preview
      const previewElements = document.querySelectorAll('.drawing-preview');
      previewElements.forEach(el => el.remove());
      
      if (drawing.points.length < 1) return;
      
      const colorWithOpacity = `${drawing.properties.color}${Math.round(drawing.properties.opacity * 2.55).toString(16).padStart(2, '0')}`;
      
      switch(drawing.tool) {
        case 'line':
        case 'ray':
        case 'trendline':
          if (drawing.points.length === 2) {
            const line = createLineElement(drawing.points[0], drawing.points[1], colorWithOpacity, drawing.properties.lineWidth);
            line.classList.add('drawing-preview');
            drawingLayer.appendChild(line);
          }
          break;
        case 'horizontal-line':
          if (drawing.points.length === 1) {
            const line = createHorizontalLineElement(drawing.points[0].y, colorWithOpacity, drawing.properties.lineWidth);
            line.classList.add('drawing-preview');
            drawingLayer.appendChild(line);
          }
          break;
        case 'vertical-line':
          if (drawing.points.length === 1) {
            const line = createVerticalLineElement(drawing.points[0].x, colorWithOpacity, drawing.properties.lineWidth);
            line.classList.add('drawing-preview');
            drawingLayer.appendChild(line);
          }
          break;
        case 'rectangle':
          if (drawing.points.length === 2) {
            const rect = createRectangleElement(drawing.points[0], drawing.points[1], colorWithOpacity, drawing.properties.lineWidth);
            rect.classList.add('drawing-preview');
            drawingLayer.appendChild(rect);
          }
          break;
        case 'text':
          if (drawing.points.length === 1) {
            const text = createTextElement(drawing.points[0], "Text", colorWithOpacity);
            text.classList.add('drawing-preview');
            drawingLayer.appendChild(text);
          }
          break;
      }
    }

    function completeDrawing() {
      if (!currentDrawing) return;
      
      // Create the drawing element based on type
      let drawingElement;
      const colorWithOpacity = `${currentDrawing.properties.color}${Math.round(currentDrawing.properties.opacity * 2.55).toString(16).padStart(2, '0')}`;
      
      switch(currentDrawing.tool) {
        case 'line':
        case 'ray':
        case 'trendline':
          if (currentDrawing.points.length === 2) {
            const price1 = chart.priceToCoordinate(currentDrawing.points[0].y);
            const price2 = chart.priceToCoordinate(currentDrawing.points[1].y);
            const time1 = chart.timeToCoordinate(currentDrawing.points[0].x);
            const time2 = chart.timeToCoordinate(currentDrawing.points[1].x);
            
            const lineSeries = chart.addLineSeries({
              color: colorWithOpacity,
              lineWidth: currentDrawing.properties.lineWidth,
              lineStyle: currentDrawing.properties.lineStyle,
              priceLineVisible: false,
              lastValueVisible: false
            });
            
            lineSeries.setData([
              { time: time1, value: price1 },
              { time: time2, value: price2 }
            ]);
            
            drawingElement = {
              type: 'line',
              series: lineSeries,
              points: [...currentDrawing.points],
              options: {
                color: colorWithOpacity,
                lineWidth: currentDrawing.properties.lineWidth,
                lineStyle: currentDrawing.properties.lineStyle,
              }
            };
          }
          break;
        case 'horizontal-line':
          if (currentDrawing.points.length === 1) {
            const price = chart.priceToCoordinate(currentDrawing.points[0].y);
            const timeRange = chart.timeScale().getVisibleRange();
            
            const lineSeries = chart.addLineSeries({
              color: colorWithOpacity,
              lineWidth: currentDrawing.properties.lineWidth,
              lineStyle: currentDrawing.properties.lineStyle,
              priceLineVisible: false,
              lastValueVisible: false
            });
            
            lineSeries.setData([
              { time: timeRange.from, value: price },
              { time: timeRange.to, value: price }
            ]);
            
            drawingElement = {
              type: 'horizontal-line',
              series: lineSeries,
              point: currentDrawing.points[0],
              options: {
                color: colorWithOpacity,
                lineWidth: currentDrawing.properties.lineWidth,
                lineStyle: currentDrawing.properties.lineStyle,
              }
            };
          }
          break;
        case 'vertical-line':
          if (currentDrawing.points.length === 1) {
            const time = chart.timeToCoordinate(currentDrawing.points[0].x);
            const priceRange = chart.priceScale().getVisiblePriceRange();
            
            const lineSeries = chart.addLineSeries({
              color: colorWithOpacity,
              lineWidth: currentDrawing.properties.lineWidth,
              lineStyle: currentDrawing.properties.lineStyle,
              priceLineVisible: false,
              lastValueVisible: false
            });
            
            lineSeries.setData([
              { time: time, value: priceRange.minValue },
              { time: time, value: priceRange.maxValue }
            ]);
            
            drawingElement = {
              type: 'vertical-line',
              series: lineSeries,
              point: currentDrawing.points[0],
              options: {
                color: colorWithOpacity,
                lineWidth: currentDrawing.properties.lineWidth,
                lineStyle: currentDrawing.properties.lineStyle,
              }
            };
          }
          break;
        case 'rectangle':
          if (currentDrawing.points.length === 2) {
            const rect = createRectangleElement(currentDrawing.points[0], currentDrawing.points[1], colorWithOpacity, currentDrawing.properties.lineWidth);
            drawingElement = {
              type: 'rectangle',
              element: rect,
              points: [...currentDrawing.points],
              options: {
                color: colorWithOpacity,
                lineWidth: currentDrawing.properties.lineWidth,
              }
            };
          }
          break;
        case 'text':
          if (currentDrawing.points.length === 1) {
            const text = createTextElement(currentDrawing.points[0], "Text", colorWithOpacity);
            drawingElement = {
              type: 'text',
              element: text,
              point: currentDrawing.points[0],
              options: {
                color: colorWithOpacity,
                text: "Text"
              }
            };
          }
          break;
      }
      
      if (drawingElement) {
        // Store the drawing
        drawings.push(drawingElement);
        drawingHistory.push(JSON.parse(JSON.stringify(drawings)));
        
        // Render the drawing on chart
        renderDrawing(drawingElement);
      }
      
      // Reset current drawing
      currentDrawing = null;
      isDrawing = false;
      
      // Clear preview
      const previewElements = document.querySelectorAll('.drawing-preview');
      previewElements.forEach(el => el.remove());
    }

    function createLineElement(point1, point2, color, width) {
      const line = document.createElement('div');
      line.className = 'drawing-line';
      
      const x1 = point1.x;
      const y1 = point1.y;
      const x2 = point2.x;
      const y2 = point2.y;
      
      const length = Math.sqrt(Math.pow(x2 - x1, 2) + Math.pow(y2 - y1, 2));
      const angle = Math.atan2(y2 - y1, x2 - x1) * 180 / Math.PI;
      
      line.style.left = `${x1}px`;
      line.style.top = `${y1}px`;
      line.style.width = `${length}px`;
      line.style.height = `${width}px`;
      line.style.backgroundColor = color;
      line.style.transform = `rotate(${angle}deg)`;
      
      return line;
    }

    function createHorizontalLineElement(y, color, width) {
      const line = document.createElement('div');
      line.className = 'drawing-line';
      
      line.style.left = '0';
      line.style.top = `${y}px`;
      line.style.width = '100%';
      line.style.height = `${width}px`;
      line.style.backgroundColor = color;
      
      return line;
    }

    function createVerticalLineElement(x, color, width) {
      const line = document.createElement('div');
      line.className = 'drawing-line';
      
      line.style.left = `${x}px`;
      line.style.top = '0';
      line.style.width = `${width}px`;
      line.style.height = '100%';
      line.style.backgroundColor = color;
      
      return line;
    }

    function createRectangleElement(point1, point2, color, width) {
      const rect = document.createElement('div');
      rect.className = 'drawing';
      
      const x = Math.min(point1.x, point2.x);
      const y = Math.min(point1.y, point2.y);
      const widthRect = Math.abs(point2.x - point1.x);
      const heightRect = Math.abs(point2.y - point1.y);
      
      rect.style.left = `${x}px`;
      rect.style.top = `${y}px`;
      rect.style.width = `${widthRect}px`;
      rect.style.height = `${heightRect}px`;
      rect.style.border = `${width}px solid ${color}`;
      rect.style.backgroundColor = 'transparent';
      
      return rect;
    }

    function createTextElement(point, text, color) {
      const textEl = document.createElement('div');
      textEl.className = 'drawing-text';
      
      textEl.style.left = `${point.x}px`;
      textEl.style.top = `${point.y}px`;
      textEl.style.color = color;
      textEl.textContent = text;
      
      return textEl;
    }

    function renderDrawing(drawing) {
      if (drawing.element) {
        drawing.element.dataset.drawingId = drawings.length - 1;
        drawingLayer.appendChild(drawing.element);
      }
    }

    // Undo/redo functionality
    undoTool.addEventListener('click', () => {
      if (drawingHistory.length > 1) {
        redoHistory.push(drawings.pop());
        drawingHistory.pop();
        redrawAll();
      }
    });

    redoTool.addEventListener('click', () => {
      if (redoHistory.length > 0) {
        const redo = redoHistory.pop();
        drawings.push(redo);
        drawingHistory.push(JSON.parse(JSON.stringify(drawings)));
        redrawAll();
      }
    });

    clearTool.addEventListener('click', () => {
      if (drawings.length > 0) {
        drawingHistory.push(JSON.parse(JSON.stringify(drawings)));
        drawings.length = 0;
        redrawAll();
      }
    });

    function redrawAll() {
      // Clear all drawings from layer
      drawingLayer.innerHTML = '';
      
      // Remove all drawing series from chart
      drawings.forEach(drawing => {
        if (drawing.series) {
          chart.removeSeries(drawing.series);
        }
      });
      
      // Redraw all
      drawings.forEach(drawing => {
        if (drawing.series) {
          // Recreate series for line-based drawings
          const newSeries = chart.addLineSeries({
            color: drawing.options.color,
            lineWidth: drawing.options.lineWidth,
            lineStyle: drawing.options.lineStyle,
            priceLineVisible: false,
            lastValueVisible: false
          });
          
          if (drawing.type === 'horizontal-line') {
            const timeRange = chart.timeScale().getVisibleRange();
            newSeries.setData([
              { time: timeRange.from, value: drawing.point.y },
              { time: timeRange.to, value: drawing.point.y }
            ]);
          } else if (drawing.type === 'vertical-line') {
            const priceRange = chart.priceScale().getVisiblePriceRange();
            newSeries.setData([
              { time: drawing.point.x, value: priceRange.minValue },
              { time: drawing.point.x, value: priceRange.maxValue }
            ]);
          } else if (drawing.type === 'line' || drawing.type === 'trendline' || drawing.type === 'ray') {
            newSeries.setData([
              { time: drawing.points[0].x, value: drawing.points[0].y },
              { time: drawing.points[1].x, value: drawing.points[1].y }
            ]);
          }
          
          drawing.series = newSeries;
        } else if (drawing.element) {
          // Recreate DOM elements for other drawings
          let newElement;
          switch(drawing.type) {
            case 'rectangle':
              newElement = createRectangleElement(drawing.points[0], drawing.points[1], drawing.options.color, drawing.options.lineWidth);
              break;
            case 'text':
              newElement = createTextElement(drawing.point, drawing.options.text, drawing.options.color);
              break;
          }
          
          if (newElement) {
            drawing.element = newElement;
            drawingLayer.appendChild(newElement);
          }
        }
      });
    }

    // Indicator implementation
    document.querySelectorAll('.indicator-item').forEach(item => {
      item.addEventListener('click', () => {
        const indicatorType = item.getAttribute('data-indicator');
        addIndicator(indicatorType);
        indicatorMenu.classList.remove('active');
      });
    });

    function addIndicator(type) {
      // Remove existing indicator of this type if it exists
      if (indicators[type]) {
        chart.removeSeries(indicators[type].series);
      }
      
      let indicatorSeries;
      let indicatorData = [];
      const candleData = candleSeries.data();
      
      switch(type) {
        case 'movingaverage':
          indicatorSeries = chart.addLineSeries({
            color: '#FF6D00',
            lineWidth: 2,
            priceLineVisible: false,
            lastValueVisible: false
          });
          
          // Simple moving average calculation (20 period)
          const period = 20;
          for (let i = period - 1; i < candleData.length; i++) {
            let sum = 0;
            for (let j = 0; j < period; j++) {
              sum += candleData[i - j].close;
            }
            const avg = sum / period;
            indicatorData.push({
              time: candleData[i].time,
              value: avg
            });
          }
          break;
          
        case 'ema':
          indicatorSeries = chart.addLineSeries({
            color: '#2962FF',
            lineWidth: 2,
            priceLineVisible: false,
            lastValueVisible: false
          });
          
          // Exponential moving average calculation (20 period)
          const emaPeriod = 20;
          const multiplier = 2 / (emaPeriod + 1);
          let ema = candleData[0].close;
          indicatorData.push({
            time: candleData[0].time,
            value: ema
          });
          
          for (let i = 1; i < candleData.length; i++) {
            ema = (candleData[i].close - ema) * multiplier + ema;
            indicatorData.push({
              time: candleData[i].time,
              value: ema
            });
          }
          break;
          
        case 'rsi':
          indicatorSeries = chart.addLineSeries({
            color: '#00BFA5',
            lineWidth: 2,
            priceLineVisible: false,
            lastValueVisible: false
          });
          
          // RSI calculation (14 period)
          const rsiPeriod = 14;
          let gains = [];
          let losses = [];
          
          for (let i = 1; i < candleData.length; i++) {
            const change = candleData[i].close - candleData[i - 1].close;
            if (change >= 0) {
              gains.push(change);
              losses.push(0);
            } else {
              gains.push(0);
              losses.push(Math.abs(change));
            }
          }
          
          let avgGain = gains.slice(0, rsiPeriod).reduce((a, b) => a + b, 0) / rsiPeriod;
          let avgLoss = losses.slice(0, rsiPeriod).reduce((a, b) => a + b, 0) / rsiPeriod;
          
          for (let i = rsiPeriod; i < candleData.length; i++) {
            const rs = avgGain / avgLoss;
            const rsi = 100 - (100 / (1 + rs));
            
            indicatorData.push({
              time: candleData[i].time,
              value: rsi
            });
            
            avgGain = ((avgGain * (rsiPeriod - 1)) + gains[i]) / rsiPeriod;
            avgLoss = ((avgLoss * (rsiPeriod - 1)) + losses[i]) / rsiPeriod;
          }
          break;
          
        case 'macd':
          // MACD requires multiple series
          const macdLine = chart.addLineSeries({
            color: '#2962FF',
            lineWidth: 2,
            priceLineVisible: false,
            lastValueVisible: false
          });
          
          const signalLine = chart.addLineSeries({
            color: '#FF6D00',
            lineWidth: 2,
            priceLineVisible: false,
            lastValueVisible: false
          });
          
          const histogram = chart.addHistogramSeries({
            color: '#26a69a',
            lineWidth: 1,
            priceLineVisible: false,
            lastValueVisible: false
          });
          
          // MACD calculation (12, 26, 9)
          const shortPeriod = 12;
          const longPeriod = 26;
          const signalPeriod = 9;
          
          // Calculate EMAs
          const shortMultiplier = 2 / (shortPeriod + 1);
          const longMultiplier = 2 / (longPeriod + 1);
          
          let shortEMA = candleData[0].close;
          let longEMA = candleData[0].close;
          
          const macdValues = [];
          
          for (let i = 1; i < candleData.length; i++) {
            shortEMA = (candleData[i].close - shortEMA) * shortMultiplier + shortEMA;
            longEMA = (candleData[i].close - longEMA) * longMultiplier + longEMA;
            
            if (i >= longPeriod - 1) {
              const macd = shortEMA - longEMA;
              macdValues.push(macd);
              
              if (macdValues.length >= signalPeriod) {
                // Calculate signal line (EMA of MACD)
                let signalEMA = macdValues[0];
                const signalMultiplier = 2 / (signalPeriod + 1);
                
                for (let j = 1; j < signalPeriod; j++) {
                  signalEMA = (macdValues[j] - signalEMA) * signalMultiplier + signalEMA;
                }
                
                macdLine.update({
                  time: candleData[i].time,
                  value: macd
                });
                
                signalLine.update({
                  time: candleData[i].time,
                  value: signalEMA
                });
                
                histogram.update({
                  time: candleData[i].time,
                  value: macd - signalEMA,
                  color: (macd - signalEMA) >= 0 ? '#26a69a' : '#ef5350'
                });
              }
            }
          }
          
          indicators[type] = {
            series: [macdLine, signalLine, histogram],
            type: 'macd'
          };
          return;
          
        case 'bollinger':
          const bollingerLine = chart.addLineSeries({
            color: '#2962FF',
            lineWidth: 1,
            priceLineVisible: false,
            lastValueVisible: false
          });
          
          const upperBand = chart.addLineSeries({
            color: '#FF6D00',
            lineWidth: 1,
            priceLineVisible: false,
            lastValueVisible: false
          });
          
          const lowerBand = chart.addLineSeries({
            color: '#FF6D00',
            lineWidth: 1,
            priceLineVisible: false,
            lastValueVisible: false
          });
          
          // Bollinger Bands calculation (20 period, 2 std dev)
          const bbPeriod = 20;
          const stdDev = 2;
          
          for (let i = bbPeriod - 1; i < candleData.length; i++) {
            let sum = 0;
            for (let j = 0; j < bbPeriod; j++) {
              sum += candleData[i - j].close;
            }
            const avg = sum / bbPeriod;
            
            let sumSquared = 0;
            for (let j = 0; j < bbPeriod; j++) {
              sumSquared += Math.pow(candleData[i - j].close - avg, 2);
            }
            const deviation = Math.sqrt(sumSquared / bbPeriod);
            
            bollingerLine.update({
              time: candleData[i].time,
              value: avg
            });
            
            upperBand.update({
              time: candleData[i].time,
              value: avg + (deviation * stdDev)
            });
            
            lowerBand.update({
              time: candleData[i].time,
              value: avg - (deviation * stdDev)
            });
          }
          
          indicators[type] = {
            series: [bollingerLine, upperBand, lowerBand],
            type: 'bollinger'
          };
          return;
      }
      
      if (indicatorSeries && indicatorData.length > 0) {
        indicatorSeries.setData(indicatorData);
        indicators[type] = {
          series: indicatorSeries,
          type: type
        };
      }
    }

    // Symbol search functionality
    const symbolSearchInput = document.getElementById('symbol-search-input');
    const symbolList = document.getElementById('symbol-list');
    
    symbolSearchInput.addEventListener('input', (e) => {
      const searchTerm = e.target.value.toLowerCase();
      Array.from(symbolList.children).forEach(item => {
        const symbol = item.getAttribute('data-symbol').toLowerCase();
        if (symbol.includes(searchTerm) || item.textContent.toLowerCase().includes(searchTerm)) {
          item.style.display = 'block';
        } else {
          item.style.display = 'none';
        }
      });
    });
    
    Array.from(symbolList.children).forEach(item => {
      item.addEventListener('click', () => {
        const symbol = item.getAttribute('data-symbol');
        symbolSearchInput.value = item.textContent;
        
        // Update legend
        const legend = document.getElementById('chart-legend');
        legend.innerHTML = `
          <div class="legend-item">
            <div class="legend-color" style="background-color: #26a69a;"></div>
            <span>${symbol}</span>
          </div>
        `;
        
        // Close search
        symbolSearch.classList.remove('active');
      });
    });

    // Fullscreen functionality
    const fullscreenBtn = document.getElementById("fullscreenBtn");
    let isFullscreen = false;

    fullscreenBtn.addEventListener("click", () => {
      const container = document.getElementById("everything");

      if (!isFullscreen) {
        if (container.requestFullscreen) {
          container.requestFullscreen();
        } else if (container.webkitRequestFullscreen) {
          container.webkitRequestFullscreen();
        } else if (container.msRequestFullscreen) {
          container.msRequestFullscreen();
        }
        fullscreenBtn.innerText = "Exit Fullscreen";
      } else {
        if (document.exitFullscreen) {
          document.exitFullscreen();
        } else if (document.webkitExitFullscreen) {
          document.webkitExitFullscreen();
        } else if (document.msExitFullscreen) {
          document.msExitFullscreen();
        }
        fullscreenBtn.innerText = "Fullscreen";
      }

      isFullscreen = !isFullscreen;
    });

    // Resize chart when fullscreen or window size changes
    function resizeChart() {
      chart.resize(
        document.getElementById("chartContainer").clientWidth,
        document.getElementById("chartContainer").clientHeight
      );
      
      // Redraw all drawings to maintain positions
      redrawAll();
    }

    window.addEventListener("resize", resizeChart);
    document.addEventListener("fullscreenchange", resizeChart);
    document.addEventListener("webkitfullscreenchange", resizeChart);
    document.addEventListener("msfullscreenchange", resizeChart);

    // Keyboard shortcuts
    document.addEventListener('keydown', (e) => {
      // Tool shortcuts
      if (e.key === 'v') activateTool(selectTool);
      if (e.key === 'c') activateTool(crosshairTool);
      if (e.key === 'l') activateTool(lineTool);
      if (e.key === 'r') activateTool(rayTool);
      if (e.key === 'h') activateTool(horizontalLineTool);
      if (e.key === 'v' && e.shiftKey) activateTool(verticalLineTool);
      if (e.key === 't') activateTool(trendlineTool);
      if (e.key === 'd') activateTool(channelTool);
      if (e.key === 'f') activateTool(fibonacciTool);
      if (e.key === 's') activateTool(rectangleTool);
      if (e.key === 'o') activateTool(circleTool);
      if (e.key === 'p') activateTool(triangleTool);
      if (e.key === 'a') activateTool(textTool);
      if (e.key === 'i') activateTool(arrowTool);
      if (e.key === 'u') activateTool(measureTool);
      
      // Undo/redo
      if (e.ctrlKey && e.key === 'z') undoTool.click();
      if (e.ctrlKey && e.key === 'y') redoTool.click();
      
      // Escape current drawing
      if (e.key === 'Escape') {
        currentDrawing = null;
        isDrawing = false;
        const previewElements = document.querySelectorAll('.drawing-preview');
        previewElements.forEach(el => el.remove());
        activateTool(crosshairTool);
      }
    });
  </script>
</body>
</html>